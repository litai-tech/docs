{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Litai Tech documentation","text":"<p>Litai Tech specializes on everything that flies (from Ukrainian \"litai (\u043b\u0456\u0442\u0430\u0439)\" means \"to fly\"). Our first product is Colir One - flight controller for model rocketry with everything you needed to launch, monitor, control your rocket. Check full documentation</p>"},{"location":"Colir%20One/0-introduction/","title":"Introduction","text":"<p>Colir One is the flight controller which has built in:</p> <ul> <li>STMicroelectronics\u00ae STM32F405 MCU</li> <li>Bosch Sensortec\u00ae BNO055 9-axis absolute orientation sensor (IMU)</li> <li>Pressure sensor for altitude and vertical velocity estimation</li> <li>Pins to connect your favourite GPS</li> <li>8 outputs for servo (5V, up to 2A current)</li> <li>6 outputs for e-igniters (5V, up to 3A)</li> <li>Nordic Semiconductor\u00ae nRF24L01 - for data telemetry</li> <li>8MB flash memory for logs</li> <li>SD card slot to copy logs from flash memory</li> <li>Debug interface to debug your code</li> </ul> <p>To use flight controller you will also need Ground Station, which will receive telemetry data from flight controller and will display some data on built-in screen and output all the data via USB Serial interface.</p>"},{"location":"Colir%20One/Flight%20Controller/radio-communication/","title":"Radio Communication","text":"<p>Radio communication between ground station and flight controler is based on NRF24L01 chip. This chip is a transceiver, which means that it can send and receive data, but it can do only ONE ROLE at the time. It means that it can be either in send OR receive mode. Which means, that in order to be able to send and receive data to and from flight controller we need to switch roles (for example when flight controller sends data, ground station is in receiver mode, then they switch roles and ground station will send command to flight controller, then they again switch roles again and again and again...)</p>"},{"location":"Colir%20One/Flight%20Controller/radio-communication/#configuration","title":"Configuration","text":"<p>The only configuration that you will need to change is the TX and RX addresses. This address is just an array of bytes (the size of the array &lt;= 6).</p> <p>TX address on ground station should be equal to RX address on flight controller (because ground station transmits data and flight controller receives it). RX address on ground station should be equal to TX address on flight controller (because ground station receives data and flight controller transmits it).</p>"},{"location":"Colir%20One/Flight%20Controller/radio-communication/#example","title":"Example","text":"<p>Go to ground_station.ino file and find these lines</p> ground_station.ino<pre><code>const byte RxAddress[5] = {0xEE,0xDD,0xCC,0xBB,0xAA};\nconst byte TxAddress[5] = {0xAA,0xDD,0xCC,0xBB,0xAA};\n</code></pre> <p>You can also set address as the string <pre><code>const byte RxAddress[5] = \"00001\";\nconst byte TxAddress[5] = \"00002\";\n</code></pre></p> <p>And now go to the main.cpp file for flight controller code and set respectful addresses their as well:</p> main.cpp<pre><code>const uint8_t RxAddress[] = {0xAA,0xDD,0xCC,0xBB,0xAA};\nconst uint8_t TxAddress[] = {0xEE,0xDD,0xCC,0xBB,0xAA};\n</code></pre> <p>Or</p> <pre><code>const byte RxAddress[5] = \"00002\";\nconst byte TxAddress[5] = \"00001\";\n</code></pre>"},{"location":"Colir%20One/Flight%20Controller/radio-communication/#communication-data","title":"Communication Data","text":"<p>NRF24L01 chip can send or receive 32 bytes of data at once. Under the hood it accepts the byte array which you want to send. But for easier communication we've built structs for sending telemetry data and commands (under the hood, struct will be converted to bytes and then on receiver side, these bytes will be translated to struct).</p> <p>We have struct called sensor_packet_t which will be sent to ground station</p>"},{"location":"Colir%20One/Ground%20Station/0-introduction/","title":"Introduction","text":"<p>Ground Station is based on ESP32 and has built-in NRF24L01 with PA+LNA IC which allows to extend the range of communication. It also has 2 buttons which can be used to send different commands (by default, its: Open Parachute, Close Parachute and Fire Igniter).</p> <p>You can find full code in official repo</p>"},{"location":"Colir%20One/Ground%20Station/buttons/","title":"Buttons","text":"<p>Ground station has 2 buttons, which you can customize as you want. But in our example we use it to control parachute and to send launch rocket command.</p> <p>The code for buttons is simple: there are 2 functions which are used as callbacks. It means that when there is an button event (button pressed and button released) respected function will be called. In our case those functions are:</p> <pre><code>void buttonPressedCallback(uint8_t pinIn)\nvoid buttonReleasedCallback(uint8_t pinIn)\n</code></pre> <p>Where \"pinIn\" parameter is a GPIO pin of the button. Those pins are defined on these lines of code:</p> <pre><code>#define BUTTON_1                            13\n#define BUTTON_2                            14\n</code></pre> <p>So, to add event handling, you can just add code in the function. Here is an example:</p> <pre><code>if(pinIn == BUTTON_1){\n    colirone_payload_cmd_t colirone_payload_cmd = {0};\n    colirone_payload_cmd.lighter_launch_number = 1;\n    enqueue_cmd(colirone_payload_cmd);\n}\nelse if(pinIn == BUTTON_2){\n    colirone_payload_cmd_t colirone_payload_cmd = {0};\n    colirone_payload_cmd.open_shutes = 1;\n    enqueue_cmd(colirone_payload_cmd);\n}\n</code></pre> <p>But if you don't want to use 1 callback for both buttons, you can just change callbacks registration in setup() function:</p> <pre><code>openShutesButton.registerCallbacks(button1PressedCallback, button1ReleasedCallback);\ncloseShutesButton.registerCallbacks(button2PressedCallback, button2ReleasedCallback);\n</code></pre> <p>And add new functions somewhere at the bottom of the file with the code</p> <pre><code>void button1PressedCallback(uint8_t pinIn)\n{\n    //handle here pressed event for BUTTON_1\n}\n\nvoid button1ReleasedCallback(uint8_t pinIn)\n{\n    //handle here released even for BUTTON_1\n}\n\n//and the same for button2 functions\n</code></pre>"},{"location":"Colir%20One/Ground%20Station/radio-communication/","title":"Radio Communication","text":"<p>Radio communication between ground station and flight controler is based on nRF24L01 chip. This chip is a transceiver, which means that it can send and receive data, but it can do only ONE ROLE at the time. It means that it can be either in send OR receive mode. Which means, that in order to be able to send and receive data to and from flight controller we need to switch roles (for example when flight controller sends data, ground station is in receiver mode, then they switch roles and ground station will send command to flight controller, then they again switch roles again and again and again...)</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#configuration","title":"Configuration","text":"<p>The only configuration that you will need to change is the TX and RX addresses. This address is just an array of bytes (the size of the array &lt;= 6).</p> <p>TX address on ground station should be equal to RX address on flight controller (because ground station transmits data and flight controller receives it). RX address on ground station should be equal to TX address on flight controller (because ground station receives data and flight controller transmits it).</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#example","title":"Example","text":"<p>Go to ground_station.ino file and find these lines</p> ground_station.ino<pre><code>const byte RxAddress[5] = {0xEE,0xDD,0xCC,0xBB,0xAA};\nconst byte TxAddress[5] = {0xAA,0xDD,0xCC,0xBB,0xAA};\n</code></pre> <p>You can also set address as the string <pre><code>const byte RxAddress[5] = \"00001\";\nconst byte TxAddress[5] = \"00002\";\n</code></pre></p> <p>And now go to the main.cpp file for flight controller code and set respectful addresses their as well:</p> main.cpp<pre><code>const uint8_t RxAddress[] = {0xAA,0xDD,0xCC,0xBB,0xAA};\nconst uint8_t TxAddress[] = {0xEE,0xDD,0xCC,0xBB,0xAA};\n</code></pre> <p>Or</p> <pre><code>const byte RxAddress[5] = \"00002\";\nconst byte TxAddress[5] = \"00001\";\n</code></pre>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#switching-txrx-modes","title":"Switching TX/RX modes","text":"<p>As it was mentioned before, nRF24L01 chip cannot receive and transmit data at once, it needs to be eaither in RX or in TX mode. In order to solve this, ground station is always in RX mode, but flight controller can send specific command to ground station, which will tell ground station to switch to TX mode, which will tell ground station, that flight controller is switched to RX mode and started listening to commands from ground station. This intervals can be configured on flight controller side. And if ground station has command to send, it sends it to flight controller and switches to RX mode back and flight controller switches to TX mode, to continue sending the telemetry data.</p> <p>When you use our code for ground station, to switch to TX role and send command, you can use transmit_cmd function:</p> <pre><code>void transmit_cmd(colirone_payload_cmd_t colirone_payload_cmd)\n</code></pre> <p>It will stop listening (switch to TX mode), send the command and will start listening (switch to RX mode).</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#communication-data","title":"Communication Data","text":"<p>nRF24L01 chip can send or receive 32 bytes of data at once. Under the hood it accepts the byte array which you want to send. But for easier communication we've built structs for sending telemetry data and commands (under the hood, struct will be converted to bytes and then on receiver side, these bytes will be translated to struct).</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#receiving-data","title":"Receiving Data","text":"<p>When nRF24L01 chip is in RX mode, it will \"listen\" for incoming data on RxAddress and when there is some data radio.available() will return \"true\". Then you need to read data from chip to your local buffer:</p> <pre><code>if(adio.available())\n    radio.read(buffer, sizeof(buffer));\n</code></pre> <p>And then you can convert this buffer to your data. In our code we use the first byte to indicate what kind of data was sent (is it data from sensors or \"switch to TX mode\" command).</p> <pre><code>uint8_t packet_type = buffer[0];\nswitch (packet_type) {\n    case 1: {\n        // handle switch to TX mode command and send command to flight controller\n        break;\n    }\n    case 0: {\n        //handle received sensor data\n        sensor_packet_t sensor_packet;\n        memcpy(&amp;sensor_packet, buffer, sizeof(sensor_packet_t));\n        break;\n    }\n    default:\n        Serial.println(\"Unknown packet type received.\");\n        break;\n}\n</code></pre>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#sensor_packet_t","title":"sensor_packet_t","text":"<p>In order to send telemetry data, we have struct called sensor_packet_t which will be packed to bytes and sent to ground station. It looks like this:</p> <pre><code>typedef struct __attribute__((packed)) {\n    uint8_t type;\n    uint8_t packet_type;      \n    uint32_t timestamp;\n    uint8_t data[26]; // 32 - 1 - 1 - 4 = 26\n} sensor_packet_t;\n</code></pre>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#type","title":"type","text":"type <p>\"type\" is the type of packet (0 for data, type != 0 for custom data). So, on ground station, we will take the first byte from the packet, and will check if it's \"0\" -&gt; we will try to parse it to sensor_packet_t struct, if type != 0 -&gt; you can add your custom handler.</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#packet_type","title":"packet_type","text":"packet_type <p>\"packet_type\" is related to the type of sensor data type.</p> <p>Packet types described as enum:</p> <pre><code>typedef enum{\n    RF_ACCELERATION = 0,\n    RF_GYROSCOPE,\n    RF_ORIENTATION,\n    RF_QUATERNION,\n    RF_BAROMETER,\n    RF_GPS,\n    RF_VERTICAL_VELOCITY,\n} rf_packet_type_t;\n</code></pre>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#timestamp","title":"timestamp","text":"timestamp <p>\"timestamp\" is the timestamp when the data was read from sensor.</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#data","title":"data","text":"data <p>\"data\" is actual data from sensor converted to bytes.</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#received-data-handling","title":"Received Data Handling","text":"<p>So, when ground station will handle received data it will take the first byte, check if it's sensor data type, if yes -&gt; check packet_type and convert \"data\" bytes to actual sensor struct. And then, you can display this data on the display or send data via serial to the application on a laptop.</p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#sending-data","title":"Sending Data","text":"<p>As we assume, that user will send only commands (open close shutes, launch rocket, start logging, etc.) from ground station to flight controller, we've build this communication based on commands. </p>"},{"location":"Colir%20One/Ground%20Station/radio-communication/#colirone_payload_cmd_t","title":"colirone_payload_cmd_t","text":"<p>\"colirone_payload_cmd_t\" struct has fields, which are actually \"flags\" what flight controller should to do. And in flight controller you should add handling to these commands (for example your parachute can be ignited by charge or released by servo).</p> colirone_payload_cmd_t <pre><code>typedef struct __attribute__((packed)) {\n    uint8_t lighter_launch_number;\n    uint8_t close_shutes;\n    uint8_t open_shutes;\n    uint8_t start_logs;\n    uint8_t write_logs;\n    uint8_t reset_altitude;\n    uint8_t remove_logs;\n} colirone_payload_cmd_t;\n</code></pre> <p>For example, you want to send \"open_shutes\" command. (this event can be triggered by button or received command from serial port). You need only to add this command to the queue and it will be sent during next switch to TX role.</p> <pre><code>colirone_payload_cmd_t colirone_payload_cmd = {0};\ncolirone_payload_cmd.open_shutes = 1;\nenqueue_cmd(colirone_payload_cmd);\n</code></pre>"}]}